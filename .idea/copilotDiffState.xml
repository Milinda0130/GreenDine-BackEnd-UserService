<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/edu/icet/ecom/security/UserPrincipal.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/edu/icet/ecom/security/UserPrincipal.java" />
              <option name="originalContent" value="package edu.icet.ecom.security;&#10;&#10;import edu.icet.ecom.dto.UserDTO;&#10;&#10;import org.springframework.security.core.GrantedAuthority;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;&#10;import java.util.Collection;&#10;import java.util.Collections;&#10;import java.util.List;&#10;public class UserPrincipal implements UserDetails {&#10;    private final UserDTO user;&#10;&#10;    public UserPrincipal(UserDTO user) {&#10;        this.user = user;&#10;    }&#10;&#10;&#10;&#10;    @Override&#10;    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {&#10;        return Collections.singleton(new SimpleGrantedAuthority(&quot;USER&quot;));&#10;    }&#10;&#10;    @Override&#10;    public String getPassword() {&#10;        return user.getPassword();&#10;    }&#10;&#10;    @Override&#10;    public String getUsername() {&#10;        return user.getEmail();&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonExpired() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonLocked() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isCredentialsNonExpired() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isEnabled() {&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package edu.icet.ecom.security;&#10;&#10;import edu.icet.ecom.dto.UserDTO;&#10;&#10;import org.springframework.security.core.GrantedAuthority;&#10;import org.springframework.security.core.authority.SimpleGrantedAuthority;&#10;import org.springframework.security.core.userdetails.UserDetails;&#10;&#10;import java.io.Serializable;&#10;import java.util.Collection;&#10;import java.util.Collections;&#10;&#10;public class UserPrincipal implements UserDetails, Serializable {&#10;    private static final long serialVersionUID = 1L;&#10;    &#10;    private transient final UserDTO user;&#10;&#10;    public UserPrincipal(UserDTO user) {&#10;        this.user = user;&#10;    }&#10;&#10;    @Override&#10;    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {&#10;        return Collections.singleton(new SimpleGrantedAuthority(&quot;USER&quot;));&#10;    }&#10;&#10;    @Override&#10;    public String getPassword() {&#10;        return user.getPassword();&#10;    }&#10;&#10;    @Override&#10;    public String getUsername() {&#10;        return user.getEmail();&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonExpired() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isAccountNonLocked() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isCredentialsNonExpired() {&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean isEnabled() {&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/edu/icet/ecom/service/impl/UserServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/edu/icet/ecom/service/impl/UserServiceImpl.java" />
              <option name="originalContent" value="package edu.icet.ecom.service.impl;&#10;&#10;import edu.icet.ecom.dto.UserDTO;&#10;import edu.icet.ecom.entity.UserEntity;&#10;import edu.icet.ecom.repository.UserRepository;&#10;import edu.icet.ecom.service.UserService;&#10;import javax.persistence.EntityNotFoundException;&#10;import javax.transaction.Transactional;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import org.modelmapper.ModelMapper;&#10;import org.springframework.dao.DataIntegrityViolationException;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.Date;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserServiceImpl implements UserService {&#10;&#10;    private static final String UPPERCASE_PATTERN = &quot;.*[A-Z].*&quot;;&#10;    private static final String LOWERCASE_PATTERN = &quot;.*[a-z].*&quot;;&#10;    private static final String DIGIT_PATTERN = &quot;.*\\d.*&quot;;&#10;&#10;    private final UserRepository userRepository;&#10;    private final ModelMapper modelMapper;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final JWTServiceImpl jwtService;&#10;    private final AuthenticationManager authenticationManager;&#10;    @Override&#10;    @Transactional&#10;    public void createUser(UserDTO userDTO) {&#10;        String validationResult = validateUser(userDTO);&#10;        if (validationResult != null) {&#10;            throw new IllegalArgumentException(validationResult);&#10;        }&#10;        userDTO.setPassword(passwordEncoder.encode(userDTO.getPassword()));&#10;&#10;&#10;        try {&#10;            UserEntity user = modelMapper.map(userDTO, UserEntity.class);&#10;            userRepository.save(user);&#10;            log.info(&quot;User created successfully with ID: {}&quot;, user.getId());&#10;        } catch (DataIntegrityViolationException e) {&#10;            log.error(&quot;Error creating user: {}&quot;, e.getMessage());&#10;            throw new DataIntegrityViolationException(&quot;Error creating user&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public UserDTO getUserById(Long id) {&#10;        UserEntity user = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;User not found with id: &quot; + id));&#10;        return modelMapper.map(user, UserDTO.class);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void updateUser(Long id, UserDTO userDTO) {&#10;        String validationResult = validateUser(userDTO);&#10;        if (validationResult != null) {&#10;            throw new IllegalArgumentException(validationResult);&#10;        }&#10;&#10;        UserEntity existingUser = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;User not found with id: &quot; + id));&#10;&#10;        if (userDTO.getPassword() != null) {&#10;            userDTO.setPassword(passwordEncoder.encode(userDTO.getPassword()));&#10;        }&#10;        modelMapper.map(userDTO, existingUser);&#10;        userRepository.save(existingUser);&#10;        log.info(&quot;User updated successfully with ID: {}&quot;, id);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void deleteUser(Long id) {&#10;        if (!userRepository.existsById(id)) {&#10;            throw new EntityNotFoundException(&quot;User not found with id: &quot; + id);&#10;        }&#10;        userRepository.deleteById(id);&#10;        log.info(&quot;User deleted successfully with ID: {}&quot;, id);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;UserDTO&gt; getAllUsers() {&#10;        return userRepository.findAll().stream()&#10;                .map(user -&gt; modelMapper.map(user, UserDTO.class))&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    @Override&#10;    public UserDTO getUserByEmail(String email) {&#10;        UserEntity user = userRepository.findByemail(email);&#10;        if (user == null) {&#10;            throw new EntityNotFoundException(&quot;User not found with email: &quot; + email);&#10;        }&#10;        return modelMapper.map(user, UserDTO.class);&#10;    }&#10;&#10;    @Override&#10;    public String validateUser(UserDTO userDTO) {&#10;        Long id = userDTO.getId();&#10;        String username = userDTO.getUsername();&#10;        String fullname = userDTO.getFullname();&#10;        String email = userDTO.getEmail();&#10;        String password = userDTO.getPassword();&#10;        String confirmPassword = userDTO.getConfirmPassword();&#10;        Date dateOfBirth = userDTO.getDateOfBirth();&#10;        String phoneNumber = userDTO.getPhoneNumber();&#10;&#10;        // Validate email&#10;        if (email == null || email.isEmpty() || !email.matches(&quot;^[\\w.+-]+@[\\w-]+\\.[a-zA-Z]{2,}$&quot;)) {&#10;            return &quot;Invalid email format.&quot;;&#10;        }&#10;&#10;        // Validate password requirement for new users&#10;        if (id == null &amp;&amp; password == null) {&#10;            return &quot;Password is required for new users.&quot;;&#10;        }&#10;&#10;        // Validate password if provided&#10;        if (password != null &amp;&amp; !isValidPassword(password, confirmPassword)) {&#10;            return getPasswordValidationError(password, confirmPassword);&#10;        }&#10;&#10;        // Validate fullname&#10;        if (fullname == null || fullname.length() &lt; 3) {&#10;            return &quot;Name must be at least 3 characters.&quot;;&#10;        }&#10;&#10;        // Validate username&#10;        if (username == null || username.length() &lt; 3) {&#10;            return &quot;username must be at least 3 characters.&quot;;&#10;        }&#10;&#10;        // Validate date of birth&#10;        if (dateOfBirth == null) {&#10;            return &quot;Date of Birth must be in the format YYYY-MM-DD.&quot;;&#10;        }&#10;&#10;        // Validate phone number&#10;        if (phoneNumber == null || !phoneNumber.matches(&quot;^\\d{10}$&quot;)) {&#10;            return &quot;Phone number must be exactly 10 digits.&quot;;&#10;        }&#10;&#10;        // Check for duplicate email on new user creation&#10;        if (id == null) {&#10;            UserEntity existingUser = userRepository.findByemail(email);&#10;            if (existingUser != null) {&#10;                return &quot;Email is already in use.&quot;;&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private boolean isValidPassword(String password, String confirmPassword) {&#10;        return password.length() &gt;= 8 &amp;&amp;&#10;               password.matches(UPPERCASE_PATTERN) &amp;&amp;&#10;               password.matches(LOWERCASE_PATTERN) &amp;&amp;&#10;               password.matches(DIGIT_PATTERN) &amp;&amp;&#10;               password.equals(confirmPassword);&#10;    }&#10;&#10;    private String getPasswordValidationError(String password, String confirmPassword) {&#10;        if (password.length() &lt; 8) {&#10;            return &quot;Password must be at least 8 characters.&quot;;&#10;        }&#10;        if (!password.matches(UPPERCASE_PATTERN)) {&#10;            return &quot;Password must contain at least one uppercase letter.&quot;;&#10;        }&#10;        if (!password.matches(LOWERCASE_PATTERN)) {&#10;            return &quot;Password must contain at least one lowercase letter.&quot;;&#10;        }&#10;        if (!password.matches(DIGIT_PATTERN)) {&#10;            return &quot;Password must contain at least one digit.&quot;;&#10;        }&#10;        if (!password.equals(confirmPassword)) {&#10;            log.info(password + &quot; &quot; + confirmPassword);&#10;            return &quot;Passwords do not match.&quot;;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public void authenticateUser(String email, String password) {&#10;        UserEntity user = userRepository.findByemail(email);&#10;        if (user == null || !passwordEncoder.matches(password, user.getPassword())) {&#10;            throw new IllegalArgumentException(&quot;Invalid email or password.&quot;);&#10;        }&#10;        log.info(&quot;User authenticated successfully: {}&quot;, email);&#10;    }&#10;&#10;    @Override&#10;    public void forgotPassword(String password, String confirmPassword, String newPassword) {&#10;&#10;        if (password == null || confirmPassword == null || newPassword == null) {&#10;            throw new IllegalArgumentException(&quot;Password fields cannot be null.&quot;);&#10;        }&#10;&#10;        if (!password.equals(confirmPassword)) {&#10;            throw new IllegalArgumentException(&quot;Current password and confirm password do not match.&quot;);&#10;        }&#10;&#10;        if (newPassword.length() &lt; 8) {&#10;            throw new IllegalArgumentException(&quot;New password must be at least 8 characters.&quot;);&#10;        }&#10;&#10;        if (!newPassword.matches(UPPERCASE_PATTERN) || !newPassword.matches(LOWERCASE_PATTERN) || !newPassword.matches(DIGIT_PATTERN)) {&#10;            throw new IllegalArgumentException(&quot;New password must contain at least one uppercase letter, one lowercase letter, and one digit.&quot;);&#10;        }&#10;&#10;        // Here you would typically update the user's password in the database&#10;        // For this example, we will just log the action&#10;        log.info(&quot;Password reset successfully for user with current password: {}&quot;, password);&#10;&#10;    }&#10;&#10;&#10;&#10;    public String verify(UserDTO user) {&#10;&#10;        Authentication authenticate = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getEmail(), user.getPassword()));&#10;&#10;        if (authenticate.isAuthenticated())&#10;            return jwtService.generateToken(user.getEmail());&#10;&#10;        return &quot;User is not authenticated&quot;;&#10;&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="package edu.icet.ecom.service.impl;&#10;&#10;import edu.icet.ecom.dto.UserDTO;&#10;import edu.icet.ecom.entity.UserEntity;&#10;import edu.icet.ecom.repository.UserRepository;&#10;import edu.icet.ecom.service.UserService;&#10;import edu.icet.ecom.service.JWTService;&#10;import javax.persistence.EntityNotFoundException;&#10;import javax.transaction.Transactional;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import org.modelmapper.ModelMapper;&#10;import org.springframework.dao.DataIntegrityViolationException;&#10;import org.springframework.security.authentication.AuthenticationManager;&#10;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;&#10;import org.springframework.security.core.Authentication;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.util.Date;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;@Slf4j&#10;public class UserServiceImpl implements UserService {&#10;&#10;    private static final String UPPERCASE_PATTERN = &quot;.*[A-Z].*&quot;;&#10;    private static final String LOWERCASE_PATTERN = &quot;.*[a-z].*&quot;;&#10;    private static final String DIGIT_PATTERN = &quot;.*\\d.*&quot;;&#10;&#10;    private final UserRepository userRepository;&#10;    private final ModelMapper modelMapper;&#10;    private final PasswordEncoder passwordEncoder;&#10;    private final JWTService jwtService;&#10;    private final AuthenticationManager authenticationManager;&#10;    @Override&#10;    @Transactional&#10;    public void createUser(UserDTO userDTO) {&#10;        String validationResult = validateUser(userDTO);&#10;        if (validationResult != null) {&#10;            throw new IllegalArgumentException(validationResult);&#10;        }&#10;        userDTO.setPassword(passwordEncoder.encode(userDTO.getPassword()));&#10;&#10;&#10;        try {&#10;            UserEntity user = modelMapper.map(userDTO, UserEntity.class);&#10;            userRepository.save(user);&#10;            log.info(&quot;User created successfully with ID: {}&quot;, user.getId());&#10;        } catch (DataIntegrityViolationException e) {&#10;            log.error(&quot;Error creating user: {}&quot;, e.getMessage());&#10;            throw new DataIntegrityViolationException(&quot;Error creating user&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public UserDTO getUserById(Long id) {&#10;        UserEntity user = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;User not found with id: &quot; + id));&#10;        return modelMapper.map(user, UserDTO.class);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void updateUser(Long id, UserDTO userDTO) {&#10;        String validationResult = validateUser(userDTO);&#10;        if (validationResult != null) {&#10;            throw new IllegalArgumentException(validationResult);&#10;        }&#10;&#10;        UserEntity existingUser = userRepository.findById(id)&#10;                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;User not found with id: &quot; + id));&#10;&#10;        if (userDTO.getPassword() != null) {&#10;            userDTO.setPassword(passwordEncoder.encode(userDTO.getPassword()));&#10;        }&#10;        modelMapper.map(userDTO, existingUser);&#10;        userRepository.save(existingUser);&#10;        log.info(&quot;User updated successfully with ID: {}&quot;, id);&#10;    }&#10;&#10;    @Override&#10;    @Transactional&#10;    public void deleteUser(Long id) {&#10;        if (!userRepository.existsById(id)) {&#10;            throw new EntityNotFoundException(&quot;User not found with id: &quot; + id);&#10;        }&#10;        userRepository.deleteById(id);&#10;        log.info(&quot;User deleted successfully with ID: {}&quot;, id);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;UserDTO&gt; getAllUsers() {&#10;        return userRepository.findAll().stream()&#10;                .map(user -&gt; modelMapper.map(user, UserDTO.class))&#10;                .collect(Collectors.toList());&#10;    }&#10;&#10;    @Override&#10;    public UserDTO getUserByEmail(String email) {&#10;        UserEntity user = userRepository.findByemail(email);&#10;        if (user == null) {&#10;            throw new EntityNotFoundException(&quot;User not found with email: &quot; + email);&#10;        }&#10;        return modelMapper.map(user, UserDTO.class);&#10;    }&#10;&#10;    @Override&#10;    public String validateUser(UserDTO userDTO) {&#10;        Long id = userDTO.getId();&#10;        String username = userDTO.getUsername();&#10;        String fullname = userDTO.getFullname();&#10;        String email = userDTO.getEmail();&#10;        String password = userDTO.getPassword();&#10;        String confirmPassword = userDTO.getConfirmPassword();&#10;        Date dateOfBirth = userDTO.getDateOfBirth();&#10;        String phoneNumber = userDTO.getPhoneNumber();&#10;&#10;        // Validate email&#10;        if (email == null || email.isEmpty() || !email.matches(&quot;^[\\w.+-]+@[\\w-]+\\.[a-zA-Z]{2,}$&quot;)) {&#10;            return &quot;Invalid email format.&quot;;&#10;        }&#10;&#10;        // Validate password requirement for new users&#10;        if (id == null &amp;&amp; password == null) {&#10;            return &quot;Password is required for new users.&quot;;&#10;        }&#10;&#10;        // Validate password if provided&#10;        if (password != null &amp;&amp; !isValidPassword(password, confirmPassword)) {&#10;            return getPasswordValidationError(password, confirmPassword);&#10;        }&#10;&#10;        // Validate fullname&#10;        if (fullname == null || fullname.length() &lt; 3) {&#10;            return &quot;Name must be at least 3 characters.&quot;;&#10;        }&#10;&#10;        // Validate username&#10;        if (username == null || username.length() &lt; 3) {&#10;            return &quot;username must be at least 3 characters.&quot;;&#10;        }&#10;&#10;        // Validate date of birth&#10;        if (dateOfBirth == null) {&#10;            return &quot;Date of Birth must be in the format YYYY-MM-DD.&quot;;&#10;        }&#10;&#10;        // Validate phone number&#10;        if (phoneNumber == null || !phoneNumber.matches(&quot;^\\d{10}$&quot;)) {&#10;            return &quot;Phone number must be exactly 10 digits.&quot;;&#10;        }&#10;&#10;        // Check for duplicate email on new user creation&#10;        if (id == null) {&#10;            UserEntity existingUser = userRepository.findByemail(email);&#10;            if (existingUser != null) {&#10;                return &quot;Email is already in use.&quot;;&#10;            }&#10;        }&#10;&#10;        return null;&#10;    }&#10;&#10;    private boolean isValidPassword(String password, String confirmPassword) {&#10;        return password.length() &gt;= 8 &amp;&amp;&#10;               password.matches(UPPERCASE_PATTERN) &amp;&amp;&#10;               password.matches(LOWERCASE_PATTERN) &amp;&amp;&#10;               password.matches(DIGIT_PATTERN) &amp;&amp;&#10;               password.equals(confirmPassword);&#10;    }&#10;&#10;    private String getPasswordValidationError(String password, String confirmPassword) {&#10;        if (password.length() &lt; 8) {&#10;            return &quot;Password must be at least 8 characters.&quot;;&#10;        }&#10;        if (!password.matches(UPPERCASE_PATTERN)) {&#10;            return &quot;Password must contain at least one uppercase letter.&quot;;&#10;        }&#10;        if (!password.matches(LOWERCASE_PATTERN)) {&#10;            return &quot;Password must contain at least one lowercase letter.&quot;;&#10;        }&#10;        if (!password.matches(DIGIT_PATTERN)) {&#10;            return &quot;Password must contain at least one digit.&quot;;&#10;        }&#10;        if (!password.equals(confirmPassword)) {&#10;            log.info(password + &quot; &quot; + confirmPassword);&#10;            return &quot;Passwords do not match.&quot;;&#10;        }&#10;        return null;&#10;    }&#10;&#10;    @Override&#10;    public void authenticateUser(String email, String password) {&#10;        UserEntity user = userRepository.findByemail(email);&#10;        if (user == null || !passwordEncoder.matches(password, user.getPassword())) {&#10;            throw new IllegalArgumentException(&quot;Invalid email or password.&quot;);&#10;        }&#10;        log.info(&quot;User authenticated successfully: {}&quot;, email);&#10;    }&#10;&#10;    @Override&#10;    public void forgotPassword(String password, String confirmPassword, String newPassword) {&#10;&#10;        if (password == null || confirmPassword == null || newPassword == null) {&#10;            throw new IllegalArgumentException(&quot;Password fields cannot be null.&quot;);&#10;        }&#10;&#10;        if (!password.equals(confirmPassword)) {&#10;            throw new IllegalArgumentException(&quot;Current password and confirm password do not match.&quot;);&#10;        }&#10;&#10;        if (newPassword.length() &lt; 8) {&#10;            throw new IllegalArgumentException(&quot;New password must be at least 8 characters.&quot;);&#10;        }&#10;&#10;        if (!newPassword.matches(UPPERCASE_PATTERN) || !newPassword.matches(LOWERCASE_PATTERN) || !newPassword.matches(DIGIT_PATTERN)) {&#10;            throw new IllegalArgumentException(&quot;New password must contain at least one uppercase letter, one lowercase letter, and one digit.&quot;);&#10;        }&#10;&#10;        // Here you would typically update the user's password in the database&#10;        // For this example, we will just log the action&#10;        log.info(&quot;Password reset successfully for user with current password: {}&quot;, password);&#10;&#10;    }&#10;&#10;&#10;&#10;    public String verify(UserDTO user) {&#10;&#10;        Authentication authenticate = authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getEmail(), user.getPassword()));&#10;&#10;        if (authenticate.isAuthenticated())&#10;            return jwtService.generateToken(user.getEmail());&#10;&#10;        return &quot;User is not authenticated&quot;;&#10;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/application.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/application.properties" />
              <option name="updatedContent" value="# Database Configuration&#10;spring.datasource.url=jdbc:mysql://localhost:3306/userservice_db?createDatabaseIfNotExist=true&#10;spring.datasource.username=root&#10;spring.datasource.password=root&#10;spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver&#10;&#10;# JPA/Hibernate Configuration&#10;spring.jpa.hibernate.ddl-auto=update&#10;spring.jpa.show-sql=true&#10;spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect&#10;spring.jpa.properties.hibernate.format_sql=true&#10;&#10;# Server Configuration&#10;server.port=8080&#10;&#10;# Logging Configuration&#10;logging.level.edu.icet.ecom=DEBUG&#10;logging.level.org.springframework.security=DEBUG&#10;logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>